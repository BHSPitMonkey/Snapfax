{"version":3,"sources":["JeelizResizer.js","JeelizThreejsHelper.js","Camera.js","App.js","serviceWorker.js","index.js"],"names":["JeelizResizer","_domCanvas","_whCanvasPx","_resizeAttemptsCounter","_overSamplingFactor","_isFullScreen","_timerFullScreen","_callbackResize","_cameraResolutions","_isInvFullscreenWH","compute_overlap","whA","whB","whLandscape","whPortrait","areaTotal","areaOverlap","Math","min","update_sizeCanvas","domRect","getBoundingClientRect","round","width","height","setAttribute","on_windowResize","clearTimeout","setTimeout","resize_fullScreen","resize_canvasToFullScreen","window","reverse","faceFilter","resize","that","is_portrait","e","size_canvas","options","document","getElementById","canvasId","isFullScreen","isInvWH","onResize","addEventListener","console","log","callback","bind","overSamplingFactor","isFlipY","domElement","CSS","CSStransform","style","transform","indexOf","add_CSStransform","allResolutions","slice","forEach","wh","sort","resA","resB","bestCameraResolution","idealWidth","idealHeight","resize_canvas","JeelizHelper","_threeRenderer","_threeScene","_maxFaces","_isMultiFaces","_threeVideoMesh","_gl","_glVideoTexture","_threeVideoTexture","_faceFilterCv","_glShpCopy","_isDetected","_settings","rotationOffsetX","pivotOffsetYZ","detectionThreshold","detectionHysteresis","tweakMoveYRotateY","isDebugPivotPoint","_threeCompositeObjects","_threePivotedObjects","_detect_callback","_isVideoTextureReady","_isSeparateThreejsCanvas","detect","detectState","threeCompositeObject","i","visible","ds","detected","init","spec","detectCallback","threejsCanvas","maxFacesDetected","videoTexture","GL","canvasElement","threejsCanvasId","THREE","context","canvas","alpha","frustumCulled","threeCompositeObjectPIVOTED","add","push","pivotCubeMesh","side","depthTest","position","copy","pivot","create_threeCompositeObjects","videoScreenVertexShaderSource","videoScreenFragmentShaderSource","compile_shader","source","type","typeString","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","shader_vertex","VERTEX_SHADER","shader_fragment","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getUniformLocation","Uint8Array","needsUpdate","videoMaterial","depthWrite","vertexShader","fragmentShader","uniforms","samplerVideo","value","videoGeometry","videoScreenCorners","Float32Array","addAttribute","setIndex","Uint16Array","apply_videoTexture","renderOrder","create_videoScreen","returnedDict","videoMesh","renderer","scene","faceObjects","faceObject","get_isDetected","render","threeCamera","composer","halfTanFOV","tan","aspect","fov","PI","tweak","rx","cz","cos","rz","sz","sin","xTweak","s","yTweak","D","xv","x","yv","y","z","set","rotation","ry","update_positions3D","viewport","useProgram","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","drawElements","TRIANGLES","UNSIGNED_SHORT","state","reset","performance","now","sortFaces","bufferGeometry","axis","isInv","axisOffset","X","Y","Z","toUpperCase","sortWay","nFaces","index","count","faces","Array","array","aPos","attributes","centroids","map","face","faceIndex","ca","cb","centroid","centroidIndex","get_threeVideoTexture","threeMesh","onAfterRender","properties","update","magFilter","minFilter","create_threejsOccluder","occluderURL","occluderMesh","load","occluderGeometry","mat","basic","colorWrite","material","geometry","set_pivotOffsetYZ","pivotOffset","Camera","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","detect_callback","assertThisInitialized","onInitialResizeReady","onFaceFilterInitReady","initThreeScene","onTrack","componentDidMount","onShutter","isDetected","threeStuffs","JeelizThreejsHelper","cubeGeometry","loader","setPath","texture","wrapS","wrapT","aspecRatio","camera","EffectComposer","addPass","RenderPass","saturationEffect","HueSaturationEffect","saturation","brightnessContrastEffect","BrightnessContrastEffect","contrast","dotScreenEffect","DotScreenEffect","scale","effectPass","EffectPass","renderToScreen","isError","bestVideoSettings","NNCpath","callbackReady","callbackTrack","errCode","react_default","a","createElement","className","id","onClick","React","Component","About","Topics","_ref","match","react_router_dom","to","concat","url","react_router","path","component","Topic","exact","_ref2","params","topicId","App","Boolean","location","hostname","ReactDOM","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"8SA2NeA,EAzNQ,WAErB,IAAIC,EACFC,EACAC,EAAyB,EACzBC,EAAsB,EACtBC,GAAgB,EAChBC,GAAmB,EACnBC,GAAkB,EAChBC,EAAqB,CAEvB,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,KAAM,KACP,CAAC,KAAM,MAELC,GAAqB,EAazB,SAASC,EAAgBC,EAAKC,GAC5B,IAEIC,EAAaC,EAFEH,EAAI,GAAKA,EAAI,GACfC,EAAI,GAAKA,EAAI,IAG5BC,EAAcF,EACdG,EAAaF,IAEbC,EAAcD,EACdE,EAAaH,GAIf,IAIII,EAJAC,EACFC,KAAKC,IAAIL,EAAY,GAAIC,EAAW,IACpCG,KAAKC,IAAIL,EAAY,GAAIC,EAAW,IAkBtC,OAfID,EAAY,IAAMC,EAAW,IAAMD,EAAY,IAAMC,EAAW,GAElEC,EAAYF,EAAY,GAAKA,EAAY,GAEzCC,EAAW,GAAKD,EAAY,IAC5BC,EAAW,GAAKD,EAAY,GAG5BE,EAAYD,EAAW,GAAKA,EAAW,IAGvCC,EAAYF,EAAY,GAAKA,EAAY,GACzCE,IAAcD,EAAW,GAAKD,EAAY,IAAMC,EAAW,IAGtDE,EAAcD,EAGvB,SAASI,IACP,IAAIC,EAAUnB,EAAWoB,wBACzBnB,EAAc,CACZe,KAAKK,MAAMlB,EAAsBgB,EAAQG,OACzCN,KAAKK,MAAMlB,EAAsBgB,EAAQI,SAE3CvB,EAAWwB,aAAa,QAASvB,EAAY,IAC7CD,EAAWwB,aAAa,SAAUvB,EAAY,IAGhD,SAASwB,IACHpB,GACFqB,aAAarB,GAEfA,EAAmBsB,WAAWC,EAAmB,IAGnD,SAASC,IACP5B,EAAc,CAAC6B,OAAM,WAAgBA,OAAM,aACvCtB,GACFP,EAAY8B,UAEd/B,EAAWwB,aAAa,QAASvB,EAAY,IAC7CD,EAAWwB,aAAa,SAAUvB,EAAY,IAGhD,SAAS2B,IACPC,IACAG,IAAWC,SACX5B,GAAmB,EACfC,GACFA,IAKJ,IAAI4B,EAAO,CAETC,YAAa,WAEX,IACE,QAAIL,OAAM,WAAe,2BAArB,QAKJ,MAAOM,GACP,OAAON,OAAM,YAAkBA,OAAM,aAgBzCO,YAAa,SAASC,GAOpB,GANAtC,EAAauC,SAASC,eAAeF,EAAQG,UAC7CrC,EACkC,qBAAzBkC,EAAQI,cAAgCJ,EAAQI,aACzDlC,EAC6B,qBAApB8B,EAAQK,SAA2BL,EAAQK,QAEhDvC,EAE8B,qBAArBkC,EAAQM,WACjBtC,EAAkBgC,EAAQM,UAE5Bf,IACAC,OAAOe,iBAAiB,SAAUpB,GAAiB,OAC9C,CAIL,IAAIN,EAAUnB,EAAWoB,wBACzB,GAAsB,IAAlBD,EAAQG,OAAkC,IAAnBH,EAAQI,OAIjC,OAHAuB,QAAQC,IACN,+GAEI7C,EAAyB,QAC7BoC,EAAQU,SAAS,4BAGnBrB,WAAWO,EAAKG,YAAYY,KAAK,KAAMX,GAAU,IAKnDpC,EAAyB,EACzBC,EACwC,qBAA/BmC,EAAQY,mBACX,EACAZ,EAAQY,mBACdhC,IAI6B,qBAApBoB,EAAQa,SAA2Bb,EAAQa,SAtJ1D,SAA0BC,EAAYC,GACpC,IAAIC,EAAeF,EAAWG,MAAMC,WACD,IAA/BF,EAAaG,QAAQJ,KACzBD,EAAWG,MAAMC,UAAYH,EAAM,IAAMC,GAoJrCI,CAAiB1D,EAAY,mBAI/B,IAAI2D,EAAiBpD,EAAmBqD,MAAM,GAI1C1B,EAAKC,eACPwB,EAAeE,QAAQ,SAASC,GAC9BA,EAAG/B,YAKP4B,EAAeI,KAAK,SAASC,EAAMC,GACjC,OACExD,EAAgBwD,EAAMhE,GACtBQ,EAAgBuD,EAAM/D,KAK1B,IAAIiE,EAAuB,CACzBC,WAAYR,EAAe,GAAG,GAC9BS,YAAaT,EAAe,GAAG,IAKjChC,WAAWW,EAAQU,SAASC,KAAK,MAAM,EAAOiB,GAAuB,IAGvEG,cAAe,WAETjE,GAGJc,MAGJ,OAAOgB,EAtNc,GCiVRoC,EA9UK,WAElB,IAaIC,EAAgBC,EAAaC,EAAWC,EAC1CC,EAAiBC,EAAKC,EAAiBC,EAAgFC,EAAeC,EAAYC,EAd9IC,EAAU,CACdC,gBAAiB,EACjBC,cAAe,CAAC,GAAI,IAEpBC,mBAAoB,IACpBC,oBAAqB,IAErBC,kBAAmB,GAEnBC,mBAAmB,GAIsCC,EAAuB,GAAIC,EAAqB,GAAIC,EAAiB,KACnEC,GAAqB,EAAOC,GAAyB,EAiGlH,SAASC,EAAOC,GACdN,EAAuB5B,QAAQ,SAASmC,EAAsBC,GAC5DhB,EAAYe,EAAqBE,QACjC,IAAMC,EAAGJ,EAAYE,GACjBhB,GAAekB,EAAGC,SAASlB,EAAUG,mBAAmBH,EAAUI,qBAEhEK,GAAkBA,EAAiBM,GAAG,GAC1CD,EAAqBE,SAAQ,IACnBjB,GAAekB,EAAGC,SAASlB,EAAUG,mBAAmBH,EAAUI,sBAExEK,GAAkBA,EAAiBM,GAAG,GAC1CD,EAAqBE,SAAQ,KA0CnC,IAAIhE,EAAK,CACPmE,KAAM,SAASC,EAAMC,GAQnB,IAAIC,EAPJ/B,EAAU6B,EAAKG,iBACf5B,EAAgByB,EAAKI,aACrB9B,EAAI0B,EAAKK,GACT5B,EAAcuB,EAAKM,cACnBlC,EAAeD,EAAU,EAIrB6B,EAAKO,iBACPhB,GAAyB,GAEzBW,EAAcjE,SAASC,eAAe8D,EAAKO,kBAC7BrF,aAAa,QAASuD,EAAczD,OAClDkF,EAAchF,aAAa,SAAUuD,EAAcxD,SAEnDiF,EAAczB,EAGa,qBAAlBwB,IACTZ,EAAiBY,GAInBhC,EAAe,IAAIuC,IAAoB,CACrCC,QAAUlB,EAA0B,KAAKjB,EACzCoC,OAAQR,EACRS,SAAQpB,IAA4BS,EAAKW,SAG3CzC,EAAY,IAAIsC,IAlLpB,WACE,IAAK,IAAIb,EAAE,EAAGA,EAAExB,IAAawB,EAAE,CAG7B,IAAMD,EAAqB,IAAIc,IAC/Bd,EAAqBkB,eAAc,EACnClB,EAAqBE,SAAQ,EAE7B,IAAMiB,EAA4B,IAAIL,IAStC,GARAK,EAA4BD,eAAc,EAE1ClB,EAAqBoB,IAAID,GAEzB1B,EAAuB4B,KAAKrB,GAC5BN,EAAqB2B,KAAKF,GAC1B3C,EAAY4C,IAAIpB,GAEZd,EAAUM,kBAAkB,CAC9B,IAAM8B,EAAc,IAAIR,IAAW,IAAIA,IAAkB,GAAI,GAAI,IAAM,IAAIA,IAAyB,CAClGS,KAAMT,IACNU,WAAW,KAEbF,EAAcG,SAASC,KAAKP,EAA4BM,UACxDzB,EAAqBoB,IAAIE,GACzBxF,OAAO6F,MAAML,EACbxE,QAAQC,IAAI,oJA2Jd6E,GAtJJ,WACE,IAAMC,EAAgC,2KAMhCC,EAAkC,uLAOxC,GAAIjC,EAAJ,CACE,IAAMkC,EAAe,SAASC,EAAQC,EAAMC,GAC1C,IAAMC,EAASvD,EAAIwD,aAAaH,GAGhC,OAFArD,EAAIyD,aAAaF,EAAQH,GACzBpD,EAAI0D,cAAcH,GACbvD,EAAI2D,mBAAmBJ,EAAQvD,EAAI4D,gBAIjCL,GAHLM,MAAM,YAAYP,EAAY,aAAetD,EAAI8D,iBAAiBP,KAC3D,IAKLQ,EAAcZ,EAAeF,EAA+BjD,EAAIgE,cAAe,UAC/EC,EAAgBd,EAAeD,EAAiClD,EAAIkE,gBAAiB,YAE3F9D,EAAWJ,EAAImE,gBACfnE,EAAIoE,aAAahE,EAAY2D,GAC7B/D,EAAIoE,aAAahE,EAAY6D,GAE7BjE,EAAIqE,YAAYjE,GACGJ,EAAIsE,mBAAmBlE,EAAY,oBApBxD,EA0BAF,EAAqB,IAAIgC,IAAmB,IAAIqC,WAAW,CAAC,IAAI,EAAE,IAAK,EAAG,EAAGrC,MAC1DsC,aAAY,EAG/B,IAAMC,EAAgB,IAAIvC,IAAwB,CAChDwC,YAAY,EACZ9B,WAAW,EACX+B,aAAc1B,EACd2B,eAAgB1B,EACf2B,SAAS,CACRC,aAAc,CAACC,MAAO7E,MAGpB8E,EAAgB,IAAI9C,IACpB+C,EAAqB,IAAIC,aAAa,EAAE,GAAG,EAAK,GAAG,EAAK,EAAE,GAAM,EAAE,IACxEF,EAAcG,aAAc,WAAY,IAAIjD,IAAuB+C,EAAoB,IACvFD,EAAcI,SAAS,IAAIlD,IAAsB,IAAImD,YAAY,CAAC,EAAE,EAAE,EAAG,EAAE,EAAE,IAAK,IAClFtF,EAAkB,IAAImC,IAAW8C,EAAeP,GAChDnH,EAAKgI,mBAAmBvF,GACxBA,EAAgBwF,aAAa,IAC7BxF,EAAgBuC,eAAc,EAC9B1C,EAAY4C,IAAIzC,IA0FdyF,GAEA,IAAMC,EAAe,CACnBC,UAAW3F,EACX4F,SAAUhG,EACViG,MAAOhG,GAOT,OALIE,EACF2F,EAAaI,YAAY/E,EAEzB2E,EAAaK,WAAWhF,EAAqB,GAExC2E,GAGTvE,OAAQ,SAASC,GAIfD,EAHUpB,EAAeqB,EAAY,CAACA,KAMxC4E,eAAgB,WACd,OAAO1F,GAGT2F,OAAQ,SAAS7E,EAAa8E,EAAaC,GACzC,IAAM3E,EAAIzB,EAAeqB,EAAY,CAACA,GAGtCD,EAAOK,GArGX,SAA4BA,EAAI0E,GAC9B,IAAME,EAAW/J,KAAKgK,IAAIH,EAAYI,OAAOJ,EAAYK,IAAIlK,KAAKmK,GAAG,KAErE1F,EAAuB5B,QAAQ,SAASmC,EAAsBC,GAC5D,GAAKD,EAAqBE,QAA1B,CACA,IAAMH,EAAYI,EAAGF,GAGfmF,EAAMlG,EAAUK,kBAAkBvE,KAAKgK,IAAIjF,EAAYsF,IACvDC,EAAGtK,KAAKuK,IAAIxF,EAAYyF,IAAKC,EAAGzK,KAAK0K,IAAI3F,EAAYyF,IAErDG,EAAOF,EAAGL,EAAMrF,EAAY6F,EAC5BC,EAAOP,EAAGF,GAAOrF,EAAY6F,EAAEf,EAAYI,QAI3Ca,EAAE,GAAG,EADH/F,EAAY6F,EACLb,GAGTgB,EAAGhG,EAAYiG,EAAEL,EACjBM,EAAGlG,EAAYmG,EAAEL,EAGjBM,GAAGL,EAAE,GACLE,EAAED,EAAGD,EAAEf,EACPmB,EAAED,EAAGH,EAAEf,EAAWF,EAAYI,OAGpCvF,EAAqBO,GAAGwB,SAAS2E,KAAKX,EAAGvG,EAAUE,cAAc,IAAIkG,EAAGpG,EAAUE,cAAc,IAAKF,EAAUE,cAAc,IAG7HY,EAAqByB,SAAS2E,IAAIJ,EAAEE,EAAEhH,EAAUE,cAAc,GAAG+G,EAAEjH,EAAUE,cAAc,IAC3FY,EAAqBqG,SAASD,IAAIrG,EAAYsF,GAAGnG,EAAUC,gBAAiBY,EAAYuG,GAAIvG,EAAYyF,GAAI,UAsE5Ge,CAAmBpG,EAAI0E,GAEnBhF,GAEFjB,EAAI4H,SAAS,EAAE,EAAGzH,EAAczD,MAAOyD,EAAcxD,QACrDqD,EAAI6H,WAAWzH,GACfJ,EAAI8H,cAAc9H,EAAI+H,UACtB/H,EAAIgI,YAAYhI,EAAIiI,WAAYhI,GAChCD,EAAIkI,aAAalI,EAAImI,UAAW,EAAGnI,EAAIoI,eAAgB,IAIvDzI,EAAe0I,MAAMC,QAIvBpC,EAASF,OAAOuC,YAAYC,QAG9BC,UAAW,SAASC,EAAgBC,EAAMC,GAQxC,IANA,IAAMC,EAAW,CAACC,EAAE,EAAGC,EAAE,EAAGC,EAAE,GAAGL,EAAKM,eAChCC,EAASN,GAAQ,EAAE,EAGnBO,EAAOT,EAAeU,MAAMC,MAAM,EAClCC,EAAM,IAAIC,MAAMJ,GACb9H,EAAE,EAAGA,EAAE8H,IAAU9H,EACxBiI,EAAMjI,GAAG,CAACqH,EAAeU,MAAMI,MAAM,EAAEnI,GAAIqH,EAAeU,MAAMI,MAAM,EAAEnI,EAAE,GAAIqH,EAAeU,MAAMI,MAAM,EAAEnI,EAAE,IAI/G,IAAMoI,EAAKf,EAAegB,WAAW7G,SAAS2G,MACxCG,EAAUL,EAAMM,IAAI,SAASC,EAAMC,GACvC,MAAO,EACJL,EAAK,EAAEI,EAAK,IAAIJ,EAAK,EAAEI,EAAK,IAAIJ,EAAK,EAAEI,EAAK,KAAK,GACjDJ,EAAK,EAAEI,EAAK,GAAG,GAAGJ,EAAK,EAAEI,EAAK,GAAG,GAAGJ,EAAK,EAAEI,EAAK,GAAG,IAAI,GACvDJ,EAAK,EAAEI,EAAK,GAAG,GAAGJ,EAAK,EAAEI,EAAK,GAAG,GAAGJ,EAAK,EAAEI,EAAK,GAAG,IAAI,EACxDA,KAKJF,EAAUxK,KAAK,SAAS4K,EAAIC,GAC1B,OAAQD,EAAGlB,GAAYmB,EAAGnB,IAAaK,IAIzCS,EAAU1K,QAAQ,SAASgL,EAAUC,GACnC,IAAML,EAAKI,EAAS,GACpBvB,EAAeU,MAAMI,MAAM,EAAEU,GAAeL,EAAK,GACjDnB,EAAeU,MAAMI,MAAM,EAAEU,EAAc,GAAGL,EAAK,GACnDnB,EAAeU,MAAMI,MAAM,EAAEU,EAAc,GAAGL,EAAK,MAIvDM,sBAAuB,WACrB,OAAOjK,GAGToF,mBAAoB,SAAS8E,GACvBpJ,IAGJoJ,EAAUC,cAAc,WAEtB,IACE1K,EAAe2K,WAAWC,OAAOrK,EAAoB,iBAAkBD,GACvEC,EAAmBsK,UAAUtI,IAC7BhC,EAAmBuK,UAAUvI,IAC7BlB,GAAqB,EACrB,MAAMxD,GACNU,QAAQC,IAAI,sFAEPiM,EAAUC,iBAKrBK,uBAAwB,SAASC,EAAavM,GAC5C,IAAMwM,EAAa,IAAI1I,IAcvB,OAbA,IAAIA,KAA6B2I,KAAKF,EAAa,SAASG,GAC1D,IAAMC,EAAI,IAAI7I,IAAqB,CACjCyC,aAAczC,IAAgB8I,MAAMrG,aACpCC,eAAgB,iFAChBC,SAAU3C,IAAgB8I,MAAMnG,SAChCoG,YAAY,IAGdL,EAAarF,aAAa,EAC1BqF,EAAaM,SAASH,EACtBH,EAAaO,SAASL,EACC,qBAAZ1M,GAA2BA,GAAUA,EAASwM,KAEpDA,GAETQ,kBAjKO,SAiKWC,GAChB/K,EAAUE,cAAgB6K,IAG9B,OAAO/N,EA3UW,WC+ILgO,qBAlIb,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KAEDQ,gBAAkBP,EAAKO,gBAAgB1N,KAArBoN,OAAAO,EAAA,EAAAP,CAAAD,IACvBA,EAAKS,qBAAuBT,EAAKS,qBAAqB5N,KAA1BoN,OAAAO,EAAA,EAAAP,CAAAD,IAC5BA,EAAKU,sBAAwBV,EAAKU,sBAAsB7N,KAA3BoN,OAAAO,EAAA,EAAAP,CAAAD,IAC7BA,EAAKW,eAAiBX,EAAKW,eAAe9N,KAApBoN,OAAAO,EAAA,EAAAP,CAAAD,IACtBA,EAAKY,QAAUZ,EAAKY,QAAQ/N,KAAboN,OAAAO,EAAA,EAAAP,CAAAD,IACfA,EAAKa,kBAAoBb,EAAKa,kBAAkBhO,KAAvBoN,OAAAO,EAAA,EAAAP,CAAAD,IACzBA,EAAKc,UAAYd,EAAKc,UAAUjO,KAAfoN,OAAAO,EAAA,EAAAP,CAAAD,IACjBA,EAAKxF,OAASwF,EAAKxF,OAAO3H,KAAZoN,OAAAO,EAAA,EAAAP,CAAAD,IAVGA,+EAaH1B,EAAWyC,GACrBA,EACFrO,QAAQC,IAAI,wCAEZD,QAAQC,IAAI,2EAIDuD,GACb,IAAM8K,EAAcC,EAAoBhL,KAAKC,EAAMiK,KAAKI,iBAClDnG,EAAQ4G,EAAY5G,MACpBD,EAAW6G,EAAY7G,SAGvB+G,EAAe,IAAIxK,IAAkB,EAAG,EAAG,GAE7CyK,EAAS,IAAIzK,IACjByK,EAAOC,QAAQ,KAEf,IAAIC,EAAUF,EAAO9B,KAAK,iBAC1BgC,EAAQC,MAAQ5K,IAChB2K,EAAQE,MAAQ7K,IAEhB,IAAIgJ,EAAW,IAAIhJ,IAAwB,CACzC0H,IAAKiD,IAIW,IAAI3K,IAAWwK,EAAcxB,GACrC5I,eAAgB,EAI1B,IAAI0K,EAAatL,EAAKM,cAActF,MAAQgF,EAAKM,cAAcrF,OAC/DgP,KAAKsB,OAAS,IAAI/K,IAAwB,GAAI8K,EAAY,GAAK,KAG/DrB,KAAKzF,SAAW,IAAIgH,IAAevH,GACnCgG,KAAKzF,SAASiH,QAAQ,IAAIC,IAAWxH,EAAO+F,KAAKsB,SAGjD,IAAMI,EAAmB,IAAIC,IAAoB,CAAEC,YAAa,IAC1DC,EAA2B,IAAIC,IAAyB,CAAEC,SAAU,KACpEC,EAAkB,IAAIC,IAAgB,CAACC,MAAO,IAK9CC,EAAa,IAAIC,IACrBpC,KAAKsB,OACLI,EACAG,EACAG,GAEFG,EAAWE,gBAAiB,EAC5BrC,KAAKzF,SAASiH,QAAQW,gDAGHG,EAASC,GAE5BhQ,QAAQC,IAAI,OAAQ+P,GAEpBhQ,QAAQC,IAAI,iBACZD,QAAQC,IAAIf,KACZA,IAAWqE,KAAK,CAGd5D,SAAU,sBACVsQ,QAAS,WACTC,cAAezC,KAAKO,sBAGpBmC,cAAe1C,KAAKS,wDAIFkC,EAAS5M,GACzB4M,EACFpQ,QAAQC,IAAI,iCAAkCmQ,IAIhDpQ,QAAQC,IAAI,mCACZwN,KAAKQ,eAAezK,oCAGdP,GACNsL,EAAoBzG,OAAO7E,EAAawK,KAAKsB,OAAQtB,KAAKzF,sDAI1DhI,QAAQC,IAAIhD,GACZ+C,QAAQC,IAAI,mBACZhD,EAAcsC,YAAY,CACxBI,SAAU,sBACVO,SAAUuN,KAAKM,uEAKjB,OAAO,wEAQP,OACEsC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,2BACbH,EAAAC,EAAAC,cAAA,UAAQ/R,MAAM,MAAMC,OAAO,MAAMgS,GAAG,wBACpCJ,EAAAC,EAAAC,cAAA,UAAQC,UAAU,UAAUE,QAASjD,KAAKW,oBA7H7BuC,IAAMC,YCa3B,SAASC,IACP,OACER,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,oBAKN,SAASO,EAATC,GAA2B,IAATC,EAASD,EAATC,MAChB,OACEX,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,oBACAF,EAAAC,EAAAC,cAAA,UACEF,EAAAC,EAAAC,cAAA,UACEF,EAAAC,EAAAC,cAACU,EAAA,EAAD,CAAMC,GAAE,GAAAC,OAAKH,EAAMI,IAAX,eAAR,yBAEFf,EAAAC,EAAAC,cAAA,UACEF,EAAAC,EAAAC,cAACU,EAAA,EAAD,CAAMC,GAAE,GAAAC,OAAKH,EAAMI,IAAX,gBAAR,eAEFf,EAAAC,EAAAC,cAAA,UACEF,EAAAC,EAAAC,cAACU,EAAA,EAAD,CAAMC,GAAE,GAAAC,OAAKH,EAAMI,IAAX,mBAAR,oBAIJf,EAAAC,EAAAC,cAACc,EAAA,EAAD,CAAOC,KAAI,GAAAH,OAAKH,EAAMM,KAAX,aAA4BC,UAAWC,IAClDnB,EAAAC,EAAAC,cAACc,EAAA,EAAD,CACEI,OAAK,EACLH,KAAMN,EAAMM,KACZxJ,OAAQ,kBAAMuI,EAAAC,EAAAC,cAAA,wCAMtB,SAASiB,EAATE,GAA0B,IAATV,EAASU,EAATV,MACf,OACEX,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,UAAKS,EAAMW,OAAOC,UAKTC,MAnEf,WACE,OACExB,EAAAC,EAAAC,cAACU,EAAA,EAAD,KACEZ,EAAAC,EAAAC,cAAA,OAAKC,UAAU,eAabH,EAAAC,EAAAC,cAACc,EAAA,EAAD,CAAOI,OAAK,EAACH,KAAK,IAAIC,UAAWnE,IACjCiD,EAAAC,EAAAC,cAACc,EAAA,EAAD,CAAOC,KAAK,SAASC,UAAWV,IAChCR,EAAAC,EAAAC,cAACc,EAAA,EAAD,CAAOC,KAAK,UAAUC,UAAWT,OCXrBgB,QACW,cAA7B9S,OAAO+S,SAASC,UAEe,UAA7BhT,OAAO+S,SAASC,UAEhBhT,OAAO+S,SAASC,SAAShB,MACvB,2DCZNiB,IAASnK,OAAOuI,EAAAC,EAAAC,cAAC2B,EAAD,MAASzS,SAASC,eAAe,SD2H3C,kBAAmByS,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.060710b6.chunk.js","sourcesContent":["import faceFilter from \"facefilter\";\n\nconst JeelizResizer = (function() {\n  //private vars :\n  var _domCanvas,\n    _whCanvasPx,\n    _resizeAttemptsCounter = 0,\n    _overSamplingFactor = 1,\n    _isFullScreen = false,\n    _timerFullScreen = false,\n    _callbackResize = false;\n  var _cameraResolutions = [\n    //all resolutions should be in landscape mode\n    [640, 480],\n    [768, 480],\n    [800, 600],\n    [960, 640],\n    [960, 720],\n    [1024, 768],\n    [1280, 720]\n  ];\n  var _isInvFullscreenWH = false;\n\n  //private functions\n  function add_CSStransform(domElement, CSS) {\n    var CSStransform = domElement.style.transform;\n    if (CSStransform.indexOf(CSS) !== -1) return;\n    domElement.style.transform = CSS + \" \" + CSStransform;\n  }\n\n  //compute overlap between 2 rectangles A and B\n  //characterized by their width and their height in pixels\n  //the rectangles are centered\n  //return the ratio (pixels overlaped)/(total pixels)\n  function compute_overlap(whA, whB) {\n    var aspectRatioA = whA[0] / whA[1],\n      aspectRatioB = whB[0] / whB[1]; //higher aspectRatio -> more landscape\n    var whLandscape, whPortrait;\n    if (aspectRatioA > aspectRatioB) {\n      whLandscape = whA;\n      whPortrait = whB;\n    } else {\n      whLandscape = whB;\n      whPortrait = whA;\n    }\n\n    //the overlapped area will be always a rectangle\n    var areaOverlap =\n      Math.min(whLandscape[0], whPortrait[0]) *\n      Math.min(whLandscape[1], whPortrait[1]);\n\n    var areaTotal;\n    if (whLandscape[0] >= whPortrait[0] && whLandscape[1] >= whPortrait[1]) {\n      //union is a rectangle\n      areaTotal = whLandscape[0] * whLandscape[1];\n    } else if (\n      whPortrait[0] > whLandscape[0] &&\n      whPortrait[1] > whLandscape[1]\n    ) {\n      //union is a rectangle\n      areaTotal = whPortrait[0] * whPortrait[1];\n    } else {\n      //union is a cross\n      areaTotal = whLandscape[0] * whLandscape[1];\n      areaTotal += (whPortrait[1] - whLandscape[1]) * whPortrait[0];\n    }\n\n    return areaOverlap / areaTotal;\n  } //end compute_overlap()\n\n  function update_sizeCanvas() {\n    var domRect = _domCanvas.getBoundingClientRect();\n    _whCanvasPx = [\n      Math.round(_overSamplingFactor * domRect.width),\n      Math.round(_overSamplingFactor * domRect.height)\n    ];\n    _domCanvas.setAttribute(\"width\", _whCanvasPx[0]);\n    _domCanvas.setAttribute(\"height\", _whCanvasPx[1]);\n  }\n\n  function on_windowResize() {\n    if (_timerFullScreen) {\n      clearTimeout(_timerFullScreen);\n    }\n    _timerFullScreen = setTimeout(resize_fullScreen, 50);\n  }\n\n  function resize_canvasToFullScreen() {\n    _whCanvasPx = [window[\"innerWidth\"], window[\"innerHeight\"]];\n    if (_isInvFullscreenWH) {\n      _whCanvasPx.reverse();\n    }\n    _domCanvas.setAttribute(\"width\", _whCanvasPx[0]);\n    _domCanvas.setAttribute(\"height\", _whCanvasPx[1]);\n  }\n\n  function resize_fullScreen() {\n    resize_canvasToFullScreen();\n    faceFilter.resize();\n    _timerFullScreen = false;\n    if (_callbackResize) {\n      _callbackResize();\n    }\n  }\n\n  //public methods :\n  var that = {\n    //return true or false if the device is in portrait or landscape mode\n    is_portrait: function() {\n      //https://stackoverflow.com/questions/4917664/detect-viewport-orientation-if-orientation-is-portrait-display-alert-message-ad\n      try {\n        if (window[\"matchMedia\"](\"(orientation: portrait)\")[\"matches\"]) {\n          return true;\n        } else {\n          return false;\n        }\n      } catch (e) {\n        return window[\"innerHeight\"] > window[\"innerWidth\"];\n      }\n    },\n\n    //size canvas to the right resolution\n    //should be called after the page loading\n    //when the canvas has already the right size\n    //options:\n    // - <string> canvasId: id of the canvas\n    // - <function> callback: function to launch if there was an error or not\n    // - <float> overSamplingFactor: facultative. If 1, same resolution than displayed size (default).\n    //   If 2, resolution twice higher than real size\n    // - <boolean> isFlipY: if we should flip the canvas or not. Default: false\n    // - <boolean> isFullScreen: if we should set the canvas fullscreen. Default : false\n    // - <function> onResize: function called when the window is resized. Only enabled if isFullScreen=true\n    // - <boolean> isInvWH: if we should invert width and height for fullscreen mode only. default=false\n    size_canvas: function(options) {\n      _domCanvas = document.getElementById(options.canvasId);\n      _isFullScreen =\n        typeof options.isFullScreen !== \"undefined\" && options.isFullScreen;\n      _isInvFullscreenWH =\n        typeof options.isInvWH !== \"undefined\" && options.isInvWH;\n\n      if (_isFullScreen) {\n        //we are in fullscreen mode\n        if (typeof options.onResize !== \"undefined\") {\n          _callbackResize = options.onResize;\n        }\n        resize_canvasToFullScreen();\n        window.addEventListener(\"resize\", on_windowResize, false);\n      } else {\n        //not fullscreen mode\n\n        //get display size of the canvas\n        var domRect = _domCanvas.getBoundingClientRect();\n        if (domRect.width === 0 || domRect.height === 0) {\n          console.log(\n            \"WARNING in JeelizResize.size_canvas() : the canvas has its width or its height null, Retry a bit later...\"\n          );\n          if (++_resizeAttemptsCounter > 20) {\n            options.callback(\"CANNOT_RESIZECANVAS\");\n            return;\n          }\n          setTimeout(that.size_canvas.bind(null, options), 50);\n          return;\n        }\n\n        //do resize canvas :\n        _resizeAttemptsCounter = 0;\n        _overSamplingFactor =\n          typeof options.overSamplingFactor === \"undefined\"\n            ? 1\n            : options.overSamplingFactor;\n        update_sizeCanvas();\n      }\n\n      //flip horizontally if required :\n      if (typeof options.isFlipY !== \"undefined\" && options.isFlipY) {\n        add_CSStransform(_domCanvas, \"rotateY(180deg)\");\n      }\n\n      //compute the best camera resolutions :\n      var allResolutions = _cameraResolutions.slice(0);\n\n      //if we are in portrait mode, the camera is also in portrait mode\n      //so we need to set all resolutions to portrait mode\n      if (that.is_portrait()) {\n        allResolutions.forEach(function(wh) {\n          wh.reverse();\n        });\n      }\n\n      //sort camera resolutions from the best to the worst :\n      allResolutions.sort(function(resA, resB) {\n        return (\n          compute_overlap(resB, _whCanvasPx) -\n          compute_overlap(resA, _whCanvasPx)\n        );\n      });\n\n      //pick the best camera resolution\n      var bestCameraResolution = {\n        idealWidth: allResolutions[0][0],\n        idealHeight: allResolutions[0][1]\n      };\n\n      //launch the callback function after a small interval to let it\n      //some time to size\n      setTimeout(options.callback.bind(null, false, bestCameraResolution), 1);\n    }, //end size_canvas()\n\n    resize_canvas: function() {\n      //should be called if the canvas is resized to update the canvas resolution\n      if (_isFullScreen) {\n        return;\n      }\n      update_sizeCanvas();\n    }\n  }; //end that\n  return that;\n})();\n\nexport default JeelizResizer;\n","import * as THREE from \"three\";\n\n/*\n  Helper for Three.js\n*/ \nconst JeelizHelper=(function(){\n  //internal settings\n  const _settings={\n    rotationOffsetX: 0, //negative -> look upper. in radians\n    pivotOffsetYZ: [0.4,0.2], //[0.2,0.2], //XYZ of the distance between the center of the cube and the pivot. enable _settings.isDebugPivotPoint to set this value\n    \n    detectionThreshold: 0.75, //sensibility, between 0 and 1. Less -> more sensitive\n    detectionHysteresis: 0.05,\n\n    tweakMoveYRotateY: 0.5, //tweak value: move detection window along Y axis when rotate the face\n    \n    isDebugPivotPoint: false //display a small cube for the pivot point\n  };\n\n  //private vars :\n  var _threeRenderer, _threeScene, _maxFaces, _isMultiFaces, _threeCompositeObjects=[], _threePivotedObjects=[], _detect_callback=null,\n    _threeVideoMesh, _gl, _glVideoTexture, _threeVideoTexture, _isVideoTextureReady=false, _isSeparateThreejsCanvas=false, _faceFilterCv, _glShpCopy, _isDetected;\n\n  //private funcs :\n  function create_threeCompositeObjects(){\n    for (let i=0; i<_maxFaces; ++i){\n      //COMPOSITE OBJECT WHICH WILL FOLLOW A DETECTED FACE\n      //in fact we create 2 objects to be able to shift the pivot point\n      const threeCompositeObject=new THREE.Object3D();\n      threeCompositeObject.frustumCulled=false;\n      threeCompositeObject.visible=false;\n\n      const threeCompositeObjectPIVOTED=new THREE.Object3D(); \n      threeCompositeObjectPIVOTED.frustumCulled=false;\n      //threeCompositeObjectPIVOTED.position.set(0, -_settings.pivotOffsetYZ[0], -_settings.pivotOffsetYZ[1]);\n      threeCompositeObject.add(threeCompositeObjectPIVOTED);\n\n      _threeCompositeObjects.push(threeCompositeObject);\n      _threePivotedObjects.push(threeCompositeObjectPIVOTED);\n      _threeScene.add(threeCompositeObject);\n\n      if (_settings.isDebugPivotPoint){\n        const pivotCubeMesh=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshNormalMaterial({\n          side: THREE.DoubleSide,\n          depthTest: false\n        }));\n        pivotCubeMesh.position.copy(threeCompositeObjectPIVOTED.position);\n        threeCompositeObject.add(pivotCubeMesh);\n        window.pivot=pivotCubeMesh;\n        console.log('DEBUG in JeelizHelper: set the position of <pivot> in the console and report the value into JeelizThreejsHelper.js for _settings.pivotOffsetYZ');\n      }\n    }\n  }\n\n  function create_videoScreen(){\n    const videoScreenVertexShaderSource = \"attribute vec2 position;\\n\\\n        varying vec2 vUV;\\n\\\n        void main(void){\\n\\\n          gl_Position=vec4(position, 0., 1.);\\n\\\n          vUV=0.5+0.5*position;\\n\\\n        }\";\n    const videoScreenFragmentShaderSource = \"precision lowp float;\\n\\\n        uniform sampler2D samplerVideo;\\n\\\n        varying vec2 vUV;\\n\\\n        void main(void){\\n\\\n          gl_FragColor=texture2D(samplerVideo, vUV);\\n\\\n        }\";\n\n    if (_isSeparateThreejsCanvas){\n      const compile_shader=function(source, type, typeString) {\n        const shader = _gl.createShader(type);\n        _gl.shaderSource(shader, source);\n        _gl.compileShader(shader);\n        if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {\n          alert(\"ERROR IN \"+typeString+ \" SHADER : \" + _gl.getShaderInfoLog(shader));\n          return false;\n        }\n        return shader;\n      };\n\n      const shader_vertex=compile_shader(videoScreenVertexShaderSource, _gl.VERTEX_SHADER, 'VERTEX');\n      const shader_fragment=compile_shader(videoScreenFragmentShaderSource, _gl.FRAGMENT_SHADER, 'FRAGMENT');\n\n      _glShpCopy=_gl.createProgram();\n      _gl.attachShader(_glShpCopy, shader_vertex);\n      _gl.attachShader(_glShpCopy, shader_fragment);\n\n      _gl.linkProgram(_glShpCopy);\n      const samplerVideo=_gl.getUniformLocation(_glShpCopy, 'samplerVideo');\n \n      return;\n    }\n\n    //init video texture with red\n    _threeVideoTexture = new THREE.DataTexture( new Uint8Array([255,0,0]), 1, 1, THREE.RGBFormat);\n    _threeVideoTexture.needsUpdate=true;\n\n    //CREATE THE VIDEO BACKGROUND\n    const videoMaterial = new THREE.RawShaderMaterial({\n      depthWrite: false,\n      depthTest: false,\n      vertexShader: videoScreenVertexShaderSource,\n      fragmentShader: videoScreenFragmentShaderSource,\n       uniforms:{\n        samplerVideo: {value: _threeVideoTexture}\n       }\n    });\n    const videoGeometry = new THREE.BufferGeometry()\n    const videoScreenCorners = new Float32Array([-1,-1,   1,-1,   1,1,   -1,1]);\n    videoGeometry.addAttribute( 'position', new THREE.BufferAttribute( videoScreenCorners, 2 ) );\n    videoGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0,1,2, 0,2,3]), 1));\n    _threeVideoMesh = new THREE.Mesh(videoGeometry, videoMaterial);\n    that.apply_videoTexture(_threeVideoMesh);\n    _threeVideoMesh.renderOrder=-1000; //render first\n    _threeVideoMesh.frustumCulled=false;\n    _threeScene.add(_threeVideoMesh);\n  } //end create_videoScreen()\n\n  function detect(detectState){\n    _threeCompositeObjects.forEach(function(threeCompositeObject, i){\n      _isDetected=threeCompositeObject.visible;\n      const ds=detectState[i];\n      if (_isDetected && ds.detected<_settings.detectionThreshold-_settings.detectionHysteresis){\n          //DETECTION LOST\n        if (_detect_callback) _detect_callback(i, false);\n        threeCompositeObject.visible=false;\n      } else if (!_isDetected && ds.detected>_settings.detectionThreshold+_settings.detectionHysteresis){\n        //FACE DETECTED\n        if (_detect_callback) _detect_callback(i, true);\n        threeCompositeObject.visible=true;\n      }\n    }); //end loop on all detection slots\n  }\n\n  function update_positions3D(ds, threeCamera){\n    const halfTanFOV=Math.tan(threeCamera.aspect*threeCamera.fov*Math.PI/360); //tan(<horizontal FoV>/2), in radians (threeCamera.fov is vertical FoV)\n         \n    _threeCompositeObjects.forEach(function(threeCompositeObject, i){\n      if (!threeCompositeObject.visible) return;\n      const detectState=ds[i];\n\n      //tweak Y position depending on rx (see)\n      const tweak=_settings.tweakMoveYRotateY*Math.tan(detectState.rx);\n      const cz=Math.cos(detectState.rz), sz=Math.sin(detectState.rz);\n      \n      const xTweak=sz*tweak*detectState.s;\n      const yTweak=cz*tweak*(detectState.s/threeCamera.aspect);\n\n      //move the cube in order to fit the head\n      const W=detectState.s;    //relative width of the detection window (1-> whole width of the detection window)\n      const D=1/(2*W*halfTanFOV); //distance between the front face of the cube and the camera\n      \n      //coords in 2D of the center of the detection window in the viewport :\n      const xv=detectState.x+xTweak;\n      const yv=detectState.y+yTweak;\n      \n      //coords in 3D of the center of the cube (in the view coordinates system)\n      const z=-D-0.5;   // minus because view coordinate system Z goes backward. -0.5 because z is the coord of the center of the cube (not the front face)\n      const x=xv*D*halfTanFOV;\n      const y=yv*D*halfTanFOV/threeCamera.aspect;\n\n      //the pivot position depends on rz rotation\n      _threePivotedObjects[i].position.set(-sz*_settings.pivotOffsetYZ[0],-cz*_settings.pivotOffsetYZ[0], -_settings.pivotOffsetYZ[1]);\n\n      //move and rotate the cube\n      threeCompositeObject.position.set(x,y+_settings.pivotOffsetYZ[0],z+_settings.pivotOffsetYZ[1]);\n      threeCompositeObject.rotation.set(detectState.rx+_settings.rotationOffsetX, detectState.ry, detectState.rz, \"ZXY\");\n    }); //end loop on composite objects\n  }\n\n  //public methods :\n  var that={\n    init: function(spec, detectCallback){ //launched with the same spec object than callbackReady. set spec.threejsCanvasId to the ID of the threejsCanvas to be in 2 canvas mode\n      _maxFaces=spec.maxFacesDetected;\n      _glVideoTexture=spec.videoTexture;\n      _gl=spec.GL;\n      _faceFilterCv=spec.canvasElement;\n      _isMultiFaces=(_maxFaces>1);\n\n      //enable 2 canvas mode if necessary\n      var threejsCanvas;\n      if (spec.threejsCanvasId){\n        _isSeparateThreejsCanvas=true;\n        //set the threejs canvas size to the threejs canvas\n        threejsCanvas=document.getElementById(spec.threejsCanvasId);\n        threejsCanvas.setAttribute('width', _faceFilterCv.width);\n        threejsCanvas.setAttribute('height', _faceFilterCv.height);\n      } else {\n        threejsCanvas=_faceFilterCv;\n      }\n\n      if (typeof(detectCallback)!=='undefined'){\n        _detect_callback=detectCallback;\n      }\n\n       //INIT THE THREE.JS context\n      _threeRenderer=new THREE.WebGLRenderer({\n        context: (_isSeparateThreejsCanvas)?null:_gl,\n        canvas: threejsCanvas,\n        alpha: (_isSeparateThreejsCanvas || spec.alpha)?true:false\n      });\n\n      _threeScene=new THREE.Scene();\n\n      create_threeCompositeObjects();\n      create_videoScreen();\n      \n      const returnedDict = {\n        videoMesh: _threeVideoMesh,\n        renderer: _threeRenderer,\n        scene: _threeScene\n      };\n      if (_isMultiFaces){\n        returnedDict.faceObjects=_threePivotedObjects;\n      } else {\n        returnedDict.faceObject=_threePivotedObjects[0];\n      }\n      return returnedDict;\n    }, //end that.init()\n\n    detect: function(detectState){\n      const ds=(_isMultiFaces)?detectState:[detectState];\n\n      //update detection states\n      detect(ds);\n    },\n\n    get_isDetected: function() {\n      return _isDetected;\n    },\n\n    render: function(detectState, threeCamera, composer){\n      const ds=(_isMultiFaces)?detectState:[detectState];\n\n      //update detection states\n      detect(ds);\n      update_positions3D(ds, threeCamera);\n\n      if (_isSeparateThreejsCanvas){\n        //render the video texture on the faceFilter canvas :\n        _gl.viewport(0,0, _faceFilterCv.width, _faceFilterCv.height);\n        _gl.useProgram(_glShpCopy);\n        _gl.activeTexture(_gl.TEXTURE0);\n        _gl.bindTexture(_gl.TEXTURE_2D, _glVideoTexture);\n        _gl.drawElements(_gl.TRIANGLES, 3, _gl.UNSIGNED_SHORT, 0);\n      } else {\n        //reinitialize the state of THREE.JS because JEEFACEFILTER have changed stuffs\n        // -> can be VERY costly !\n        _threeRenderer.state.reset();\n      }\n\n      //trigger the render of the THREE.JS SCENE\n      composer.render(performance.now());\n    },\n\n    sortFaces: function(bufferGeometry, axis, isInv){ //sort faces long an axis\n      //useful when a bufferGeometry has alpha : we should render the last faces first\n      const axisOffset={X:0, Y:1, Z:2}[axis.toUpperCase()];\n      const sortWay=(isInv)?-1:1;\n\n      //fill the faces array\n      const nFaces=bufferGeometry.index.count/3;\n      const faces=new Array(nFaces);\n      for (let i=0; i<nFaces; ++i){\n        faces[i]=[bufferGeometry.index.array[3*i], bufferGeometry.index.array[3*i+1], bufferGeometry.index.array[3*i+2]];\n      }\n\n      //compute centroids :\n      const aPos=bufferGeometry.attributes.position.array;\n      const centroids=faces.map(function(face, faceIndex){\n        return [\n          (aPos[3*face[0]]+aPos[3*face[1]]+aPos[3*face[2]])/3, //X\n          (aPos[3*face[0]+1]+aPos[3*face[1]+1]+aPos[3*face[2]+1])/3, //Y\n          (aPos[3*face[0]+2]+aPos[3*face[1]+2]+aPos[3*face[2]+2])/3, //Z\n          face\n        ];\n      });\n\n      //sort centroids\n      centroids.sort(function(ca, cb){\n        return (ca[axisOffset]-cb[axisOffset])*sortWay;\n      });\n\n      //reorder bufferGeometry faces :\n      centroids.forEach(function(centroid, centroidIndex){\n        const face=centroid[3];\n        bufferGeometry.index.array[3*centroidIndex]=face[0];\n        bufferGeometry.index.array[3*centroidIndex+1]=face[1];\n        bufferGeometry.index.array[3*centroidIndex+2]=face[2];\n      });\n    }, //end sortFaces\n\n    get_threeVideoTexture: function(){\n      return _threeVideoTexture;\n    },\n\n    apply_videoTexture: function(threeMesh){\n      if (_isVideoTextureReady){\n        return;\n      }\n      threeMesh.onAfterRender=function(){\n        //replace _threeVideoTexture.__webglTexture by the real video texture\n        try {\n          _threeRenderer.properties.update(_threeVideoTexture, '__webglTexture', _glVideoTexture);\n          _threeVideoTexture.magFilter=THREE.LinearFilter;\n          _threeVideoTexture.minFilter=THREE.LinearFilter;\n          _isVideoTextureReady=true;\n        } catch(e){\n          console.log('WARNING in THREE.JeelizHelper : the glVideoTexture is not fully initialized');\n        }\n        delete(threeMesh.onAfterRender);\n      };\n    },\n\n    //create an occluder, IE a transparent object which writes on the depth buffer\n    create_threejsOccluder: function(occluderURL, callback){\n      const occluderMesh=new THREE.Mesh();\n      new THREE.BufferGeometryLoader().load(occluderURL, function(occluderGeometry){\n        const mat=new THREE.ShaderMaterial({\n          vertexShader: THREE.ShaderLib.basic.vertexShader,\n          fragmentShader: \"precision lowp float;\\n void main(void){\\n gl_FragColor=vec4(1.,0.,0.,1.);\\n }\",\n          uniforms: THREE.ShaderLib.basic.uniforms,\n          colorWrite: false\n        });\n        //occluderGeometry.computeVertexNormals(); mat=new THREE.MeshNormalMaterial({side: THREE.DoubleSide});\n        occluderMesh.renderOrder=-1; //render first\n        occluderMesh.material=mat;\n        occluderMesh.geometry=occluderGeometry;\n        if (typeof(callback)!=='undefined' && callback) callback(occluderMesh);\n      });\n      return occluderMesh;\n    },\n    set_pivotOffsetYZ(pivotOffset) {\n      _settings.pivotOffsetYZ = pivotOffset;\n    }\n  }\n  return that;\n})();\n\nexport default JeelizHelper;\n","import React from \"react\";\nimport * as THREE from \"three\";\nimport faceFilter from \"facefilter\";\nimport JeelizResizer from \"./JeelizResizer\";\nimport JeelizThreejsHelper from \"./JeelizThreejsHelper\";\nimport {\n  ColorDepthEffect,\n  DotScreenEffect,\n  EffectComposer,\n  HueSaturationEffect,\n  EffectPass,\n  RenderPass,\n  BlendFunction,\n  BrightnessContrastEffect\n} from \"postprocessing\";\nimport \"./App.css\";\n\nclass Camera extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.detect_callback = this.detect_callback.bind(this);\n    this.onInitialResizeReady = this.onInitialResizeReady.bind(this);\n    this.onFaceFilterInitReady = this.onFaceFilterInitReady.bind(this);\n    this.initThreeScene = this.initThreeScene.bind(this);\n    this.onTrack = this.onTrack.bind(this);\n    this.componentDidMount = this.componentDidMount.bind(this);\n    this.onShutter = this.onShutter.bind(this);\n    this.render = this.render.bind(this);\n  }\n\n  detect_callback(faceIndex, isDetected) {\n    if (isDetected) {\n      console.log(\"INFO in detect_callback() : DETECTED\");\n    } else {\n      console.log(\"INFO in detect_callback() : LOST\");\n    }\n  }\n\n  initThreeScene(spec) {\n    const threeStuffs = JeelizThreejsHelper.init(spec, this.detect_callback);\n    const scene = threeStuffs.scene;\n    const renderer = threeStuffs.renderer;\n\n    // CREATE A CUBE\n    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);\n\n    var loader = new THREE.TextureLoader();\n    loader.setPath(\"/\");\n\n    var texture = loader.load(\"./icon512.png\");\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n\n    var material = new THREE.MeshBasicMaterial({\n      map: texture\n    });\n\n    //const cubeMaterial = new THREE.MeshNormalMaterial();\n    const threeCube = new THREE.Mesh(cubeGeometry, material);\n    threeCube.frustumCulled = false;\n    //threeStuffs.faceObject.add(threeCube);\n\n    //CREATE THE CAMERA\n    var aspecRatio = spec.canvasElement.width / spec.canvasElement.height;\n    this.camera = new THREE.PerspectiveCamera(20, aspecRatio, 0.1, 100);\n\n    // Prepare postprocessing\n    this.composer = new EffectComposer(renderer);\n    this.composer.addPass(new RenderPass(scene, this.camera));\n\n    // Create effects\n    const saturationEffect = new HueSaturationEffect({ saturation: -1 });\n    const brightnessContrastEffect = new BrightnessContrastEffect({ contrast: 0.5 });\n    const dotScreenEffect = new DotScreenEffect({scale: 2});\n    // const colorDepthEffect = new ColorDepthEffect(BlendFunction.NORMAL, 2);\n    // colorDepthEffect.setBitDepth(1);\n\n    // Add the effects\n    const effectPass = new EffectPass(\n      this.camera,\n      saturationEffect,\n      brightnessContrastEffect,\n      dotScreenEffect\n    );\n    effectPass.renderToScreen = true;\n    this.composer.addPass(effectPass);\n  }\n\n  onInitialResizeReady(isError, bestVideoSettings) {\n    //init_faceFilter(bestVideoSettings);\n    console.log(\"best\", bestVideoSettings);\n\n    console.log(\"About to init\");\n    console.log(faceFilter);\n    faceFilter.init({\n      //you can also provide the canvas directly\n      //using the canvas property instead of canvasId:\n      canvasId: \"jeeFaceFilterCanvas\",\n      NNCpath: \"NNC.json\", //path to JSON neural network model (NNC.json by default)\n      callbackReady: this.onFaceFilterInitReady, //end callbackReady()\n\n      //called at each render iteration (drawing loop)\n      callbackTrack: this.onTrack\n    }); //end init call\n  }\n\n  onFaceFilterInitReady(errCode, spec) {\n    if (errCode) {\n      console.log(\"AN ERROR HAPPENS. ERROR CODE =\", errCode);\n      return;\n    }\n\n    console.log(\"INFO: JEEFACEFILTERAPI IS READY\");\n    this.initThreeScene(spec);\n  }\n\n  onTrack(detectState) {\n    JeelizThreejsHelper.render(detectState, this.camera, this.composer);\n  }\n\n  componentDidMount() {\n    console.log(JeelizResizer);\n    console.log(\"about to resize\");\n    JeelizResizer.size_canvas({\n      canvasId: \"jeeFaceFilterCanvas\",\n      callback: this.onInitialResizeReady\n    });\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  onShutter() {\n      // Store current canvas image somewhere, change the view to edit mode\n  }\n\n  render() {\n    return (\n      <div className=\"camera-view fill-screen\">\n        <canvas width=\"360\" height=\"640\" id=\"jeeFaceFilterCanvas\" />\n        <button className=\"shutter\" onClick={this.onShutter} />\n      </div>\n    );\n  }\n}\n\nexport default Camera;\n","import React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport Camera from './Camera';\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <Router>\n      <div className=\"fill-screen\">\n        {/* <ul>\n          <li>\n            <Link to=\"/\">Camera</Link>\n          </li>\n          <li>\n            <Link to=\"/about\">About</Link>\n          </li>\n          <li>\n            <Link to=\"/topics\">Topics</Link>\n          </li>\n        </ul> */}\n\n        <Route exact path=\"/\" component={Camera} />\n        <Route path=\"/about\" component={About} />\n        <Route path=\"/topics\" component={Topics} />\n      </div>\n    </Router>\n  );\n}\n\n\nfunction About() {\n  return (\n    <div>\n      <h2>About</h2>\n    </div>\n  );\n}\n\nfunction Topics({ match }) {\n  return (\n    <div>\n      <h2>Topics</h2>\n      <ul>\n        <li>\n          <Link to={`${match.url}/rendering`}>Rendering with React</Link>\n        </li>\n        <li>\n          <Link to={`${match.url}/components`}>Components</Link>\n        </li>\n        <li>\n          <Link to={`${match.url}/props-v-state`}>Props v. State</Link>\n        </li>\n      </ul>\n\n      <Route path={`${match.path}/:topicId`} component={Topic} />\n      <Route\n        exact\n        path={match.path}\n        render={() => <h3>Please select a topic.</h3>}\n      />\n    </div>\n  );\n}\n\nfunction Topic({ match }) {\n  return (\n    <div>\n      <h3>{match.params.topicId}</h3>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}