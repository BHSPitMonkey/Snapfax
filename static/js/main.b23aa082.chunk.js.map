{"version":3,"sources":["icon.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","JeelizResizer","_domCanvas","_whCanvasPx","_resizeAttemptsCounter","_overSamplingFactor","_isFullScreen","_timerFullScreen","_callbackResize","_cameraResolutions","_isInvFullscreenWH","compute_overlap","whA","whB","whLandscape","whPortrait","areaTotal","areaOverlap","Math","min","update_sizeCanvas","domRect","getBoundingClientRect","round","width","height","setAttribute","on_windowResize","clearTimeout","setTimeout","resize_fullScreen","resize_canvasToFullScreen","window","reverse","faceFilter","resize","that","is_portrait","e","size_canvas","options","document","getElementById","canvasId","isFullScreen","isInvWH","onResize","addEventListener","console","log","callback","bind","overSamplingFactor","isFlipY","domElement","CSS","CSStransform","style","transform","indexOf","add_CSStransform","allResolutions","slice","forEach","wh","sort","resA","resB","bestCameraResolution","idealWidth","idealHeight","resize_canvas","Camera","isError","bestVideoSettings","init","NNCpath","callbackReady","errCode","spec","callbackTrack","detectState","react_default","a","createElement","className","id","React","Component","About","Topics","_ref","match","react_router_dom","to","concat","url","react_router","path","component","Topic","exact","render","_ref2","params","topicId","App","Boolean","location","hostname","ReactDOM","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b23aa082.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/icon.8a7f2dba.svg\";","import React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport faceFilter from \"facefilter\";\nimport logo from \"./icon.svg\";\nimport \"./App.css\";\n\nconst JeelizResizer = (function(){\n    //private vars :\n    var _domCanvas, _whCanvasPx, _resizeAttemptsCounter=0, _overSamplingFactor=1, _isFullScreen=false, _timerFullScreen=false, _callbackResize=false;\n    var _cameraResolutions=[ //all resolutions should be in landscape mode\n        [640,480],\n        [768,480],\n        [800,600],\n        [960,640],\n        [960,720],\n        [1024,768],\n        [1280,720]\n    ];\n    var _isInvFullscreenWH=false;\n\n    //private functions\n    function add_CSStransform(domElement, CSS){\n        var CSStransform=domElement.style.transform;\n        if (CSStransform.indexOf(CSS)!==-1) return;\n        domElement.style.transform=CSS+' '+CSStransform;\n    }\n\n    //compute overlap between 2 rectangles A and B\n    //characterized by their width and their height in pixels\n    //the rectangles are centered\n    //return the ratio (pixels overlaped)/(total pixels)\n    function compute_overlap(whA, whB){ \n        var aspectRatioA=whA[0]/whA[1], aspectRatioB=whB[0]/whB[1]; //higher aspectRatio -> more landscape\n        var whLandscape, whPortrait;\n        if (aspectRatioA>aspectRatioB){ \n            whLandscape=whA;\n            whPortrait=whB;\n        } else {\n            whLandscape=whB;\n            whPortrait=whA;\n        }\n\n        //the overlapped area will be always a rectangle\n        var areaOverlap=Math.min(whLandscape[0], whPortrait[0])*Math.min(whLandscape[1], whPortrait[1]);\n        \n        var areaTotal;\n        if (whLandscape[0]>=whPortrait[0] && whLandscape[1]>=whPortrait[1]){ //union is a rectangle\n            areaTotal=whLandscape[0]*whLandscape[1];\n        } else if (whPortrait[0]>whLandscape[0] && whPortrait[1]>whLandscape[1]){ //union is a rectangle\n            areaTotal=whPortrait[0]*whPortrait[1];\n        } else { //union is a cross\n            areaTotal=whLandscape[0]*whLandscape[1];\n            areaTotal+=(whPortrait[1]-whLandscape[1])*whPortrait[0];\n        }\n\n        return areaOverlap/areaTotal;\n    } //end compute_overlap()\n\n    function update_sizeCanvas(){\n        var domRect = _domCanvas.getBoundingClientRect();\n        _whCanvasPx=[\n            Math.round(_overSamplingFactor*domRect.width),\n            Math.round(_overSamplingFactor*domRect.height)\n        ];\n        _domCanvas.setAttribute('width',  _whCanvasPx[0]);\n        _domCanvas.setAttribute('height', _whCanvasPx[1]);\n    }\n\n    function on_windowResize(){\n        if (_timerFullScreen){\n            clearTimeout(_timerFullScreen);\n        }\n        _timerFullScreen=setTimeout(resize_fullScreen, 50);\n    }\n\n    function resize_canvasToFullScreen(){\n        _whCanvasPx=[window['innerWidth'], window['innerHeight']];\n        if (_isInvFullscreenWH){\n            _whCanvasPx.reverse();\n        }\n        _domCanvas.setAttribute('width',  _whCanvasPx[0]);\n        _domCanvas.setAttribute('height', _whCanvasPx[1]);\n    }\n\n    function resize_fullScreen(){\n        resize_canvasToFullScreen();\n        faceFilter.resize();\n        _timerFullScreen=false;\n        if (_callbackResize) {\n            _callbackResize();\n        }\n    }\n\n    //public methods :\n    var that={ //return true or false if the device is in portrait or landscape mode\n        is_portrait: function(){ //https://stackoverflow.com/questions/4917664/detect-viewport-orientation-if-orientation-is-portrait-display-alert-message-ad\n            try{\n                if (window['matchMedia'](\"(orientation: portrait)\")['matches']){\n                    return true;\n                } else {\n                    return false;\n                }\n            } catch(e){\n                return (window['innerHeight'] > window['innerWidth']);\n            }\n        },\n\n        //size canvas to the right resolution\n        //should be called after the page loading\n        //when the canvas has already the right size\n        //options:\n        // - <string> canvasId: id of the canvas\n        // - <function> callback: function to launch if there was an error or not\n        // - <float> overSamplingFactor: facultative. If 1, same resolution than displayed size (default). \n        //   If 2, resolution twice higher than real size\n        // - <boolean> isFlipY: if we should flip the canvas or not. Default: false\n        // - <boolean> isFullScreen: if we should set the canvas fullscreen. Default : false\n        // - <function> onResize: function called when the window is resized. Only enabled if isFullScreen=true\n        // - <boolean> isInvWH: if we should invert width and height for fullscreen mode only. default=false\n        size_canvas: function(options){\n            _domCanvas=document.getElementById(options.canvasId);\n            _isFullScreen=(typeof(options.isFullScreen)!=='undefined' && options.isFullScreen);\n            _isInvFullscreenWH=(typeof(options.isInvWH)!=='undefined' && options.isInvWH);\n\n            if (_isFullScreen){\n                //we are in fullscreen mode\n                if (typeof(options.onResize)!=='undefined'){\n                    _callbackResize=options.onResize;\n                }\n                resize_canvasToFullScreen();\n                window.addEventListener('resize', on_windowResize, false);\n            } else { //not fullscreen mode\n\n                //get display size of the canvas\n                var domRect = _domCanvas.getBoundingClientRect();\n                if (domRect.width===0 || domRect.height===0){\n                    console.log('WARNING in JeelizResize.size_canvas() : the canvas has its width or its height null, Retry a bit later...');\n                    if (++_resizeAttemptsCounter>20){\n                        options.callback('CANNOT_RESIZECANVAS');\n                        return;\n                    }\n                    setTimeout(that.size_canvas.bind(null, options), 50);\n                    return;\n                }\n\n                //do resize canvas :\n                _resizeAttemptsCounter=0;\n                _overSamplingFactor=(typeof(options.overSamplingFactor)==='undefined')?1:options.overSamplingFactor;\n                update_sizeCanvas();\n            }\n\n            //flip horizontally if required :\n            if (typeof(options.isFlipY)!=='undefined' && options.isFlipY){\n                add_CSStransform(_domCanvas, 'rotateY(180deg)');\n            }\n\n            //compute the best camera resolutions :\n            var allResolutions=_cameraResolutions.slice(0);\n\n            //if we are in portrait mode, the camera is also in portrait mode\n            //so we need to set all resolutions to portrait mode\n            if (that.is_portrait()){\n                allResolutions.forEach(function(wh){\n                    wh.reverse();\n                });\n            }\n\n            //sort camera resolutions from the best to the worst :\n            allResolutions.sort(function(resA, resB){\n                return compute_overlap(resB, _whCanvasPx)-compute_overlap(resA, _whCanvasPx);\n            });\n\n            //pick the best camera resolution\n            var bestCameraResolution={\n                'idealWidth': allResolutions[0][0],\n                'idealHeight':allResolutions[0][1]\n            };\n\n            //launch the callback function after a small interval to let it\n            //some time to size\n            setTimeout(options.callback.bind(null, false, bestCameraResolution), 1);\n        }, //end size_canvas()\n\n        resize_canvas: function(){ //should be called if the canvas is resized to update the canvas resolution\n            if (_isFullScreen){\n                return;\n            }\n            update_sizeCanvas();\n        }\n    }; //end that\n    return that;\n})();\n\nfunction App() {\n  return (\n    <Router>\n      <div className=\"fill-screen\">\n        {/* <ul>\n          <li>\n            <Link to=\"/\">Camera</Link>\n          </li>\n          <li>\n            <Link to=\"/about\">About</Link>\n          </li>\n          <li>\n            <Link to=\"/topics\">Topics</Link>\n          </li>\n        </ul> */}\n\n        <Route exact path=\"/\" component={Camera} />\n        <Route path=\"/about\" component={About} />\n        <Route path=\"/topics\" component={Topics} />\n      </div>\n    </Router>\n  );\n}\n\nclass Camera extends React.Component {\n  componentDidMount() {\n    console.log(JeelizResizer);\n    console.log(\"about to resize\");\n    JeelizResizer.size_canvas({\n      canvasId: \"jeeFaceFilterCanvas\",\n      callback: function(isError, bestVideoSettings) {\n        //init_faceFilter(bestVideoSettings);\n        console.log(\"best\", bestVideoSettings);\n\n        console.log(\"About to init\");\n        console.log(faceFilter);\n        faceFilter.init({\n          //you can also provide the canvas directly\n          //using the canvas property instead of canvasId:\n          canvasId: \"jeeFaceFilterCanvas\",\n          NNCpath: \"NNC.json\", //path to JSON neural network model (NNC.json by default)\n          callbackReady: function(errCode, spec) {\n            if (errCode) {\n              console.log(\"AN ERROR HAPPENS. ERROR CODE =\", errCode);\n              return;\n            }\n\n            console.log(\"INFO: JEEFACEFILTERAPI IS READY\");\n          }, //end callbackReady()\n\n          //called at each render iteration (drawing loop)\n          callbackTrack: function(detectState) {\n            //render your scene here\n            //[... do something with detectState]\n          } //end callbackTrack()\n        }); //end init call\n      }\n    });\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  render() {\n    return (\n      <div className=\"camera-view fill-screen\">\n        <canvas width=\"300\" height=\"300\" id=\"jeeFaceFilterCanvas\" />\n        <button className=\"shutter\"></button>\n      </div>\n    );\n  }\n}\n\nfunction About() {\n  return (\n    <div>\n      <h2>About</h2>\n    </div>\n  );\n}\n\nfunction Topics({ match }) {\n  return (\n    <div>\n      <h2>Topics</h2>\n      <ul>\n        <li>\n          <Link to={`${match.url}/rendering`}>Rendering with React</Link>\n        </li>\n        <li>\n          <Link to={`${match.url}/components`}>Components</Link>\n        </li>\n        <li>\n          <Link to={`${match.url}/props-v-state`}>Props v. State</Link>\n        </li>\n      </ul>\n\n      <Route path={`${match.path}/:topicId`} component={Topic} />\n      <Route\n        exact\n        path={match.path}\n        render={() => <h3>Please select a topic.</h3>}\n      />\n    </div>\n  );\n}\n\nfunction Topic({ match }) {\n  return (\n    <div>\n      <h3>{match.params.topicId}</h3>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}